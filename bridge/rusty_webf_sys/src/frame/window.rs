// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
/*
* Copyright (C) 2022-present The WebF authors. All rights reserved.
*/
use std::ffi::*;
use crate::*;
#[repr(C)]
pub struct WindowRustMethods {
  pub version: c_double,
  pub event_target: EventTargetRustMethods,
  pub screen: extern "C" fn(ptr: *const OpaquePtr) -> RustValue<ScreenRustMethods>,
  pub scroll_x: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub scroll_y: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub page_x_offset: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub page_y_offset: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub device_pixel_ratio: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub color_scheme: extern "C" fn(ptr: *const OpaquePtr) -> AtomicStringRef,
  pub inner_width: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub inner_height: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub btoa: extern "C" fn(ptr: *const OpaquePtr, *const c_char, exception_state: *const OpaquePtr) -> AtomicStringRef,
  pub atob: extern "C" fn(ptr: *const OpaquePtr, *const c_char, exception_state: *const OpaquePtr) -> AtomicStringRef,
  pub open: extern "C" fn(ptr: *const OpaquePtr, *const c_char, exception_state: *const OpaquePtr) -> RustValue<WindowRustMethods>,
  pub cancel_animation_frame: extern "C" fn(ptr: *const OpaquePtr, c_double, exception_state: *const OpaquePtr) -> c_void,
  pub get_computed_style: extern "C" fn(ptr: *const OpaquePtr, *const OpaquePtr, *const c_char, exception_state: *const OpaquePtr) -> RustValue<ComputedCssStyleDeclarationRustMethods>,
}
pub struct Window {
  pub event_target: EventTarget,
  method_pointer: *const WindowRustMethods,
}
impl Window {
  pub fn initialize(ptr: *const OpaquePtr, context: *const ExecutingContext, method_pointer: *const WindowRustMethods, status: *const RustValueStatus) -> Window {
    unsafe {
      Window {
        event_target: EventTarget::initialize(
          ptr,
          context,
          &(method_pointer).as_ref().unwrap().event_target,
          status,
        ),
        method_pointer,
      }
    }
  }
  pub fn ptr(&self) -> *const OpaquePtr {
    self.event_target.ptr()
  }
  pub fn context<'a>(&self) -> &'a ExecutingContext {
    self.event_target.context()
  }
  pub fn screen(&self) -> Screen {
    let value = unsafe {
      ((*self.method_pointer).screen)(self.ptr())
    };
    Screen::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
  pub fn scroll_x(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).scroll_x)(self.ptr())
    };
    value
  }
  pub fn scroll_y(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).scroll_y)(self.ptr())
    };
    value
  }
  pub fn page_x_offset(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).page_x_offset)(self.ptr())
    };
    value
  }
  pub fn page_y_offset(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).page_y_offset)(self.ptr())
    };
    value
  }
  pub fn device_pixel_ratio(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).device_pixel_ratio)(self.ptr())
    };
    value
  }
  pub fn color_scheme(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).color_scheme)(self.ptr())
    };
    value.to_string()
  }
  pub fn inner_width(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).inner_width)(self.ptr())
    };
    value
  }
  pub fn inner_height(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).inner_height)(self.ptr())
    };
    value
  }
  pub fn btoa(&self, string: &str, exception_state: &ExceptionState) -> Result<String, String> {
    let value = unsafe {
      ((*self.method_pointer).btoa)(self.ptr(), CString::new(string).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value.to_string())
  }
  pub fn atob(&self, string: &str, exception_state: &ExceptionState) -> Result<String, String> {
    let value = unsafe {
      ((*self.method_pointer).atob)(self.ptr(), CString::new(string).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value.to_string())
  }
  pub fn open(&self, url: &str, exception_state: &ExceptionState) -> Result<Window, String> {
    let value = unsafe {
      ((*self.method_pointer).open)(self.ptr(), CString::new(url).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(Window::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
  pub fn cancel_animation_frame(&self, request_id: f64, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).cancel_animation_frame)(self.ptr(), request_id, exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn get_computed_style(&self, element: &Element, pseudo_elt: &str, exception_state: &ExceptionState) -> Result<ComputedCssStyleDeclaration, String> {
    let value = unsafe {
      ((*self.method_pointer).get_computed_style)(self.ptr(), element.ptr(), CString::new(pseudo_elt).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(ComputedCssStyleDeclaration::initialize(value.value, self.context(), value.method_pointer, value.status))
  }
}
pub trait WindowMethods: EventTargetMethods {
  fn screen(&self) -> Screen;
  fn scroll_x(&self) -> f64;
  fn scroll_y(&self) -> f64;
  fn page_x_offset(&self) -> f64;
  fn page_y_offset(&self) -> f64;
  fn device_pixel_ratio(&self) -> f64;
  fn color_scheme(&self) -> String;
  fn inner_width(&self) -> f64;
  fn inner_height(&self) -> f64;
  fn btoa(&self, string: &str, exception_state: &ExceptionState) -> Result<String, String>;
  fn atob(&self, string: &str, exception_state: &ExceptionState) -> Result<String, String>;
  fn open(&self, url: &str, exception_state: &ExceptionState) -> Result<Window, String>;
  fn cancel_animation_frame(&self, request_id: f64, exception_state: &ExceptionState) -> Result<(), String>;
  fn get_computed_style(&self, element: &Element, pseudo_elt: &str, exception_state: &ExceptionState) -> Result<ComputedCssStyleDeclaration, String>;
  fn as_window(&self) -> &Window;
}
impl WindowMethods for Window {
  fn screen(&self) -> Screen {
    self.screen()
  }
  fn scroll_x(&self) -> f64 {
    self.scroll_x()
  }
  fn scroll_y(&self) -> f64 {
    self.scroll_y()
  }
  fn page_x_offset(&self) -> f64 {
    self.page_x_offset()
  }
  fn page_y_offset(&self) -> f64 {
    self.page_y_offset()
  }
  fn device_pixel_ratio(&self) -> f64 {
    self.device_pixel_ratio()
  }
  fn color_scheme(&self) -> String {
    self.color_scheme()
  }
  fn inner_width(&self) -> f64 {
    self.inner_width()
  }
  fn inner_height(&self) -> f64 {
    self.inner_height()
  }
  fn btoa(&self, string: &str, exception_state: &ExceptionState) -> Result<String, String> {
    self.btoa(string, exception_state)
  }
  fn atob(&self, string: &str, exception_state: &ExceptionState) -> Result<String, String> {
    self.atob(string, exception_state)
  }
  fn open(&self, url: &str, exception_state: &ExceptionState) -> Result<Window, String> {
    self.open(url, exception_state)
  }
  fn cancel_animation_frame(&self, request_id: f64, exception_state: &ExceptionState) -> Result<(), String> {
    self.cancel_animation_frame(request_id, exception_state)
  }
  fn get_computed_style(&self, element: &Element, pseudo_elt: &str, exception_state: &ExceptionState) -> Result<ComputedCssStyleDeclaration, String> {
    self.get_computed_style(element, pseudo_elt, exception_state)
  }
  fn as_window(&self) -> &Window {
    self
  }
}
impl EventTargetMethods for Window {
  fn add_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &AddEventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.event_target.add_event_listener(type_, callback, options, exception_state)
  }
  fn remove_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &EventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.event_target.remove_event_listener(type_, callback, options, exception_state)
  }
  fn dispatch_event(&self, event: &Event, exception_state: &ExceptionState) -> Result<bool, String> {
    self.event_target.dispatch_event(event, exception_state)
  }
  fn as_event_target(&self) -> &EventTarget {
    &self.event_target
  }
}
